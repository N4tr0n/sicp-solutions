% Created 2019-01-01 Tue 20:20
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Nathan Hitchings}
\date{\today}
\title{Assignment 1 Solutions}
\hypersetup{
 pdfauthor={Nathan Hitchings},
 pdftitle={Assignment 1 Solutions},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.1 (Org mode 9.1.14)},
 pdflang={English}}
\begin{document}

\maketitle
\section{Exercise 1.1}
\label{sec:orge6257d6}
Below is a sequence of expressions. What is the result printed by the
interpreter in response to each expression? Assume that the sequence is
to be evaluated in the order in which it is presented.
\subsection{Solution}
\label{sec:orgd325574}
\begin{verbatim}
10 ; 10
(+ 5 3 4) ; 12
(- 9 1) ; 8
(/ 6 2) ; 3
(+ (* 2 4) (- 4 6)) ; 6
(define a 3)
(define b (+ a 1))
(+ a b (* a b)) ; 19
(= a b) ; #f
(if (and (> b a) (< b (* a b)))
    b
    a) ; 4
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25)) ; 16
(+ 2 (if (> b a) b a)) ; 6
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1)) ; 16
\end{verbatim}

\section{Exercise 1.2}
\label{sec:org617070e}
Translate the following expression into prefix form
\begin{equation}
\frac{5+4+(2-(3-(6+\frac{4}{5})))}{3(6-2)(2-7)}
\end{equation}
\subsection{Solution}
\label{sec:org4d4592a}
\begin{verbatim}
(/ (+ 5
      4
      (- 2
         (- 3
            (+ 6
               (/ 4 5)))))
   (* 3
      (- 6 2)
      (- 2 7)))
\end{verbatim}

\section{Exercise 1.3}
\label{sec:orgee67e62}
Define a procedure that takes three numbers as arguments and returns the
sum of the squares of the two larger numbers.
\subsection{Solution}
\label{sec:org0bbaf8c}
\begin{verbatim}
(define (sum-of-squares-of-larger x y z)
  (cond ((and (>= x z) (>= y z))
         (sum-of-squares x y))
        ((and (>= x y) (>= z y))
         (sum-of-squares x z))
        (else (sum-of-squares y z))))
\end{verbatim}

\section{Exercise 1.4}
\label{sec:orgc53f9cb}
Observe that our model of evaluation allows for combinations whose
operators are compound expressions. Use this observation to describe the
behavior of the following procedure:
\begin{verbatim}
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
\end{verbatim}
\subsection{Solution}
\label{sec:orgcd5735c}
This procedure uses the sign of \texttt{b} to decide whether to add \texttt{b} to \texttt{a} or
subtract \texttt{b} from \texttt{a}. If b is greater than zero then \texttt{b} is added if \texttt{b} is
less than zero then \texttt{b} is subtracted essentially resulting in adding the
absolute value of \texttt{b} to \texttt{a}.

\section{Exercise 1.5}
\label{sec:org3533fd2}
Ben Bitdiddle has invented a test to determine whether the interpreter
he is faced with is using applicative-order evaluation or normal-order
evaluation. He defines the following two procedures:
\begin{verbatim}
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
\end{verbatim}

Then he evaluates the expression
\begin{verbatim}
(test 0 (p))
\end{verbatim}

What behavior will Ben observe with an interpreter that uses
applicative-order evaluation? What behavior will he observe with an
interpreter that uses normal-order evaluation? Explain your
answer. (Assume that the evaluation rule for the special form if is the
same whether the interpreter is using normal or applicative order: The
predicate expression is evaluated first, and the result determines
whether to evaluate the consequent or the alternative expression.)
\subsection{Solution}
\label{sec:org1acbaa2}
Using applicative-order evaluation, the expression
\begin{verbatim}
(test 0 p)
\end{verbatim}
will be evaluated by first evaluating the arguments. Thus, evaluating
\texttt{p} leads to an infinite recursion and the evaluation will never
complete. Using normal-order evaluation, we will first expand the
expression then reduce. When this happens, the \texttt{if} form's condition
will evaluate to true and the result of the expression will be zero
with no attempt to evaluate p.

\section{Exercise 1.6}
\label{sec:org27f050c}
Alyssa P. Hacker doesn't see why \texttt{if} needs to be provided as a special
form. "Why can't I just define it as an ordinary procedure in terms of
\texttt{cond}?" she asks. Alyssa's friend Eva Lu Ator claims this can indeed be
done, and she defines a new version of \texttt{if}:
\begin{verbatim}
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
\end{verbatim}
Eva demonstrates the program for Alyssa:
\begin{verbatim}
(new-if (= 2 3) 0 5)
;; 5
(new-if (= 1 1) 0 5)
;; 0
\end{verbatim}
Delighted, Alyssa uses \texttt{new-if} to rewrite the square-root program:
\begin{verbatim}
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))
\end{verbatim}
What happens when Alyssa attempts to use this to compute square roots?
Explain.
\subsection{Solution}
\label{sec:org76cda86}
Since \texttt{new-if} is a procedure and must evaluate all of its arguments,
\texttt{sqrt-iter} will loop forever. This happens because \texttt{sqrt-iter} must be
evaluated before \texttt{new-if} can be applied thus calling \texttt{new-if} again
which will try to evaluate \texttt{sqrt-iter} again and so on.

\section{Exercise 1.7}
\label{sec:org5bd7930}
The \texttt{good-enough?} test used in computing square roots will not be very
effective for finding the square roots of very small numbers. Also, in
real computers, arithmetic operations are almost always performed with
limited precision. This makes our test inadequate for very large
numbers. Explain these statements, with examples showing how the test
fails for small and large numbers. An alternative strategy for
implementing \texttt{good-enough?} is to watch how \texttt{guess} changes from one
iteration to the next and to stop when the change is a very small
fraction of the guess. Design a square-root procedure that uses this
kind of end test. Does this work better for small and large numbers?
\subsection{Solution}
\label{sec:org03880b8}
For very small numbers we have a very large relative error. For
instance, in computing \texttt{(sqrt 0.001)} the difference between the
\texttt{good-enough?} result is 70\% different than the original argument.
For very large numbers the machine precision is unable to represent
small differences between large numbers.
\begin{verbatim}
(define (good-enough? previous-guess next-guess)
  (< (abs (- previous-guess next-guess)) (* 0.001 next-guess)))
(define (sqrt-iter first-guess second-guess x)
  (if (good-enough? first-guess second-guess)
      second-guess
      (sqrt-iter second-guess (improve second-guess x) x)))
(define (sqrt x)
  (sqrt-iter x 1.0 x))
\end{verbatim}

\section{Exercise 1.8}
\label{sec:org8abd7c3}
Newton's method for cube roots is based on the fact that if y is an
approximation to the cube root of x, then a better approximation is
given by the value
\begin{equation}
\frac{x/y^2+2y}{3}
\end{equation}
Use this formula to implement a cube-root procedure analogous to the
square-root procedure.
\subsection{Solution}
\label{sec:orgb838b3f}
\begin{verbatim}
(define (square x)
  (* x x))
(define (good-enough? previous-guess next-guess)
  (< (abs (- previous-guess next-guess)) (* 0.001 next-guess)))
(define (improve guess x)
  (/ (+ (/ x (square y)) (* y 2.0)) 3.0))
(define (cbrt-iter first-guess second-guess x)
  (if (good-enough? first-guess second-guess)
      second-guess
      (cbrt-iter second-guess (improve second-guess x) x)))
(define (cube-root x)
  (cbrt-iter x 1.0 x))
\end{verbatim}
\end{document}
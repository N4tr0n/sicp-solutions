* Exercise 1.1
  Below is a sequence of expressions. What is the result printed by the
  interpreter in response to each expression? Assume that the sequence is
  to be evaluated in the order in which it is presented.
** Solution
   #+BEGIN_SRC scheme
     10 ; 10
     (+ 5 3 4) ; 12
     (- 9 1) ; 8
     (/ 6 2) ; 3
     (+ (* 2 4) (- 4 6)) ; 6
     (define a 3)
     (define b (+ a 1))
     (+ a b (* a b)) ; 19
     (= a b) ; #f
     (if (and (> b a) (< b (* a b)))
         b
         a) ; 4
     (cond ((= a 4) 6)
           ((= b 4) (+ 6 7 a))
           (else 25)) ; 16
     (+ 2 (if (> b a) b a)) ; 6
     (* (cond ((> a b) a)
              ((< a b) b)
              (else -1))
        (+ a 1)) ; 16
   #+END_SRC

* Exercise 1.2
  Translate the following expression into prefix form
  #+BEGIN_HTML
  <a href="https://www.codecogs.com/eqnedit.php?latex=\frac{5&plus;4&plus;(2-(3-(6&plus;\frac{4}{5})))}{3(6-2)(2-7)}" target="_blank">
  <img src="https://latex.codecogs.com/gif.latex?\frac{5&plus;4&plus;(2-(3-(6&plus;\frac{4}{5})))}{3(6-2)(2-7)}" title="\frac{5+4+(2-(3-(6+\frac{4}{5})))}{3(6-2)(2-7)}" />
  </a>
  #+END_HTML
** Solution
   #+BEGIN_SRC scheme
     (/ (+ 5
           4
           (- 2
              (- 3
                 (+ 6
                    (/ 4 5)))))
        (* 3
           (- 6 2)
           (- 2 7)))
   #+END_SRC

* Exercise 1.3
  Define a procedure that takes three numbers as arguments and returns the
  sum of the squares of the two larger numbers.
** Solution
   #+BEGIN_SRC scheme
     (define (sum-of-squares-of-larger x y z)
       (cond ((and (>= x z) (>= y z))
              (sum-of-squares x y))
             ((and (>= x y) (>= z y))
              (sum-of-squares x z))
             (else (sum-of-squares y z))))
   #+END_SRC

* Exercise 1.4
  Observe that our model of evaluation allows for combinations whose
  operators are compound expressions. Use this observation to describe the
  behavior of the following procedure:
  #+BEGIN_SRC scheme
    (define (a-plus-abs-b a b)
      ((if (> b 0) + -) a b))
  #+END_SRC
** Solution
   This procedure uses the sign of =b= to decide whether to add =b= to =a= or
   subtract =b= from =a=. If b is greater than zero then =b= is added if =b= is
   less than zero then =b= is subtracted essentially resulting in adding the
   absolute value of =b= to =a=.

* Exercise 1.5
  Ben Bitdiddle has invented a test to determine whether the interpreter
  he is faced with is using applicative-order evaluation or normal-order
  evaluation. He defines the following two procedures:
  #+BEGIN_SRC scheme
    (define (p) (p))

    (define (test x y)
      (if (= x 0)
          0
          y))
  #+END_SRC

  Then he evaluates the expression
  #+BEGIN_SRC scheme
    (test 0 (p))
  #+END_SRC

  What behavior will Ben observe with an interpreter that uses
  applicative-order evaluation? What behavior will he observe with an
  interpreter that uses normal-order evaluation? Explain your
  answer. (Assume that the evaluation rule for the special form if is the
  same whether the interpreter is using normal or applicative order: The
  predicate expression is evaluated first, and the result determines
  whether to evaluate the consequent or the alternative expression.)
** Solution
   Using applicative-order evaluation, the expression
   #+BEGIN_SRC scheme
     (test 0 p)
   #+END_SRC
   will be evaluated by first evaluating the arguments. Thus, when the
   interpreter attempts to evaluate =p= leading to an infinite recursion
   and the evaluation will never complete.
   Using normal-order evaluation, we will first expand the expression then
   reduce. When this happens, the =if= form's condition will evaluate to
   true and the result of the expression will be zero with no attempt to
   evaluate p.

* Exercise 1.6
  Alyssa P. Hacker doesn't see why =if= needs to be provided as a special
  form. "Why can't I just define it as an ordinary procedure in terms of
  =cond=?" she asks. Alyssa's friend Eva Lu Ator claims this can indeed be
  done, and she defines a new version of =if=:
  #+BEGIN_SRC scheme
    (define (new-if predicate then-clause else-clause)
      (cond (predicate then-clause)
            (else else-clause)))
  #+END_SRC
  Eva demonstrates the program for Alyssa:
  #+BEGIN_SRC scheme
    (new-if (= 2 3) 0 5)
    ;; 5
    (new-if (= 1 1) 0 5)
    ;; 0
  #+END_SRC
  Delighted, Alyssa uses =new-if= to rewrite the square-root program:
  #+BEGIN_SRC scheme
    (define (sqrt-iter guess x)
      (new-if (good-enough? guess x)
              guess
              (sqrt-iter (improve guess x)
                         x)))
  #+END_SRC
  What happens when Alyssa attempts to use this to compute square roots?
  Explain.
** Solution
   Since =new-if= is a procedure and must evaluate all of its arguments,
   =sqrt-iter= will loop forever. This happens because =sqrt-iter= must be
   evaluated before =new-if= can be applied thus calling =new-if= again
   which will try to evaluate =sqrt-iter= again and so on.

* Exercise 1.7
  The =good-enough?= test used in computing square roots will not be very
  effective for finding the square roots of very small numbers. Also, in
  real computers, arithmetic operations are almost always performed with
  limited precision. This makes our test inadequate for very large
  number. Explain these statements, with examples showing how the test
  fails for small and large numbers. An alternative strategy for
  implementing =good-enough?= is to watch how =guess= changes from one
  iteration to the next and to stop when the change is a very small
  fraction of the guess. Design a square-root procedure that uses this
  kind of end test. Does this work better for small and large numbers?
** Solution
   For very small numbers we have a very large relative error. For
   instance, in computing =(sqrt 0.001)= the difference between the
   =good-enough?= result is 70% different than the original argument.
   For very large numbers the machine precision is unable to represent
   small differences between large numbers.
   #+BEGIN_SRC scheme
     (define (good-enough? previous-guess next-guess)
       (< (abs (- previous-guess next-guess)) (* 0.001 next-guess)))
     (define (sqrt-iter first-guess second-guess x)
       (if (good-enough? first-guess second-guess)
           second-guess
           (sqrt-iter second-guess (improve second-guess x) x)))
     (define (sqrt x)
       (sqrt-iter x 1.0 x))
   #+END_SRC

* Exercise 1.8
  Newton's method for cube roots is based on the fact that if y is an
  approximation to the cube root of x, then a better approximation is
  given by the value
  #+BEGIN_HTML
  <a href="https://www.codecogs.com/eqnedit.php?latex=\frac{x/y^2&space;&plus;&space;2y}{3}" target="_blank">
  <img src="https://latex.codecogs.com/gif.latex?\frac{x/y^2&space;&plus;&space;2y}{3}" title="\frac{x/y^2 + 2y}{3}" />
  </a>
  #+END_HTML
  Use this formula to implement a cube-root procedure analogous to the
  square-root procedure.
** Solution
   #+BEGIN_SRC scheme
     (define (square x)
       (* x x))
     (define (good-enough? previous-guess next-guess)
       (< (abs (- previous-guess next-guess)) (* 0.001 next-guess)))
     (define (improve guess x)
       (/ (+ (/ x (square y)) (* y 2.0)) 3.0))
     (define (cbrt-iter first-guess second-guess x)
       (if (good-enough? first-guess second-guess)
           second-guess
           (cbrt-iter second-guess (improve second-guess x) x)))
     (define (cube-root x)
       (cbrt-iter x 1.0 x))
   #+END_SRC

* Exercise 1.9
  Each of the following two procedures defines a method for adding two
  positive integers in terms of the procedures =inc=, which increments its
  argument by 1, and =dec=, which decrements its argument by 1.
  #+BEGIN_SRC scheme
    (define (+ a b)
      (if (= a 0)
          b
          (inc (+ (dec a) b))))

    (define (+ a b)
      (if (= a 0)
          b
          (+ (dec a) (inc b))))
  #+END_SRC
** Solution
   #+BEGIN_SRC scheme
     (inc (+ (dec 4) 5))
     (inc (+ 3 5))
     (inc (inc (+ (dec 3) 5)))
     (inc (inc (+ 2 5)))
     (inc (inc (inc (+ (dec 2) 5))))
     (inc (inc (inc (+ 1 5))))
     (inc (inc (inc (inc (+ (dec 1) 5)))))
     (inc (inc (inc (inc (+ 0 5)))))
     (inc (inc (inc (inc 5))))
     (inc (inc (inc 6)))
     (inc (inc 7))
     (inc 8)
     9

     (+ (dec 4) (inc 5))
     (+ 3 6)
     (+ (dec 3) (inc 6))
     (+ 2 7)
     (+ (dec 2) (inc 7))
     (+ 1 8)
     (+ (dec 1) (inc 8))
     (+ 0 9)
     9
   #+END_SRC
   The first process is recursive while the second process is iterative.

* Exercise 1.10
  The following procedure computes a mathematical function called Ackermann's
  function.
  #+BEGIN_SRC scheme
    (define (A x y)
      (cond ((= y 0) 0)
            ((= x 0) (* 2 y))
            ((= y 1) 2)
            (else (A (- x 1)
                     (A x (- y 1))))))
  #+END_SRC

  What are the values of the following expressions?
  #+BEGIN_SRC scheme
    (A 1 10)
    (A 2 4)
    (A 3 3)
  #+END_SRC
** Solution
   #+BEGIN_SRC scheme
     (A 1 10)
     (A 0 (A 1 9))
     (A 0 (A 0 (A 1 8)))
     (A 0 (A 0 (A 0 (A 1 7))))
     (A 0 (A 0 (A 0 (A 0 (A 1 6)))))
     (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
     (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
     (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
     (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
     (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
     (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
     (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
     (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
     (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
     (A 0 (A 0 (A 0 (A 0 (A 0 32)))))
     (A 0 (A 0 (A 0 (A 0 64))))
     (A 0 (A 0 (A 0 128)))
     (A 0 (A 0 256))
     (A 0 512)
     1024

     (A 2 4)
     (A 1 (A 2 3))
     (A 1 (A 1 (A 2 2)))
     (A 1 (A 1 (A 1 (A 2 1))))
     (A 1 (A 1 (A 1 2)))
     (A 1 (A 1 (A 0 (A 1 1))))
     (A 1 (A 1 (A 0 2)))
     (A 1 (A 1 4))
     (A 1 (A 0 (A 1 3)))
     (A 1 (A 0 (A 0 (A 1 2))))
     (A 1 (A 0 (A 0 (A 0 (A 1 1)))))
     (A 1 (A 0 (A 0 (A 0 2))))
     (A 1 (A 0 (A 0 4)))
     (A 1 (A 0 8))
     (A 1 16)
     (A 0 (A 1 15))
     (A 0 (A 0 (A 1 14)))
     (A 0 (A 0 (A 0 (A 1 13))))
     (A 0 (A 0 (A 0 (A 0 (A 1 12)))))
     (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 11))))))
     (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 10)))))))
     (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 1024))))))
     (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 1024))))))
     (A 0 (A 0 (A 0 (A 0 (A 0 2048)))))
     (A 0 (A 0 (A 0 (A 0 4096))))
     (A 0 (A 0 (A 0 8192)))
     (A 0 (A 0 16384))
     (A 0 32768)
     65536

     (A 3 3)
     (A 2 (A 3 2))
     (A 2 (A 2 (A 3 1)))
     (A 2 (A 2 2))
     (A 2 (A 1 (A 2 1)))
     (A 2 (A 1 2))
     (A 2 4)
     65536
   #+END_SRC

   Consider the following procedures, where =A= is the procedure defined above:
   #+BEGIN_SRC scheme
     (define (f n) (A 0 n))
     (define (g n) (A 1 n))
     (define (h n) (A 2 n))
     (define (k n) (* 5 n n))
   #+END_SRC

   Give concise mathematical definitions for the functions computed by the
   procedures =f=, =g=, and =h= for positive integer values of =n=. for example,
   =(k n)= computes
   #+BEGIN_HTML
   <a href="https://www.codecogs.com/eqnedit.php?latex=5n^2" target="_blank">
   <img src="https://latex.codecogs.com/gif.latex?5n^2" title="5n^2" />
   </a>
   #+END_HTML

** Solution
   =(f n)= computes
   #+BEGIN_HTML
   <a href="https://www.codecogs.com/eqnedit.php?latex=2n" target="_blank">
   <img src="https://latex.codecogs.com/gif.latex?2n" title="2n" />
   </a>
   #+END_HTML

   =(g n)= computes
   #+BEGIN_HTML
   <a href="https://www.codecogs.com/eqnedit.php?latex=2^n" target="_blank">
   <img src="https://latex.codecogs.com/gif.latex?2^n" title="2^n" />
   </a>
   #+END_HTML

   =(h n)= computes
   #+BEGIN_HTML
   <a href="https://www.codecogs.com/eqnedit.php?latex=^na" target="_blank">
   <img src="https://latex.codecogs.com/gif.latex?^na" title="^na" />
   </a>
   #+END_HTML

* Exercise 1.11
  A function /f/ is defined by the rule that
  #+BEGIN_HTML
  <a href="https://www.codecogs.com/eqnedit.php?latex=f(n)=\begin{cases}&space;n&space;&&space;n<3&space;\\&space;f(n-1)&space;&plus;&space;2f(n-2)&space;&plus;&space;3f(n-3)&space;&&space;n\geq&space;3&space;\end{cases}" target="_blank">
  <img src="https://latex.codecogs.com/gif.latex?f(n)=\begin{cases}&space;n&space;&&space;n<3&space;\\&space;f(n-1)&space;&plus;&space;2f(n-2)&space;&plus;&space;3f(n-3)&space;&&space;n\geq&space;3&space;\end{cases}" title="f(n)=\begin{cases} n & n<3 \\ f(n-1) + 2f(n-2) + 3f(n-3) & n\geq 3 \end{cases}" />
  </a>
  #+END_HTML
  Write a procedure that computes /f/ by means of a recursive procedure. Write a
  procedure that computes /f/ by means of an iterative procedure.
** Solution
   #+BEGIN_SRC scheme
  (define (f-recur n)
    (if (< n 3)
        n
        (+ (f-recur (- n 1))
           (* 2 (f-recur (- n 2)))
           (* 3 (f-recur (- n 3))))))

  (define (f n)
    (define (iter count a b c)
      (if (> n count)
          a
          (iter (+ count 1)
                b
                c
                (+ (* 3 a)
                   (* 2 b)
                   c))))
    (iter (0 0 1 2)))
   #+END_SRC
* Exercise 1.12
  The following pattern of numbers is called /Pascal's triangle/.
  *Pascal's triangle goes here*
  The numbers at the edge of the triangle are all 1, and each number
  inside the triangle is the sum of the two numbers above it. Write a
  procedure that computes elements of Pascal's triangle by means of a
  recursive process.
